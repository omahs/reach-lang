[{"bookPath":"guide","title":"Building decentralized abstractions","titleId":"guide-abstract","hasOtp":true,"hasPageHeader":true},"<h1 id=\"guide-abstract\" class=\"refHeader\">Building decentralized abstractions<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#guide-abstract\"><span class=\"icon icon-link\"></span></a></h1>\n<p><i id=\"p_0\" class=\"pid\"></i>Many decentralized applications have the same structure, similar to how there are many games that can be categorized as <a href=\"https://en.wikipedia.org/wiki/Combinatorial_game_theory\" target=\"_blank\">combinatorial games</a> or <a href=\"https://en.wikipedia.org/wiki/Simultaneous_game\" target=\"_blank\">simultaneous games</a>.<a href=\"#p_0\" class=\"pid\">0</a></p>\n<p>\n  <i id=\"p_1\" class=\"pid\"></i>These applications can either be programmed individually, or you can build an abstraction that captures the common structure of a game.\n  Reach supports typical programming language abstractions, like first-class functions (via arrow expressions) and objects, that can be used to build these abstractions.<a href=\"#p_1\" class=\"pid\">1</a>\n</p>\n<p>\n  <i id=\"p_2\" class=\"pid\"></i>When building such abstractions, the most difficult part is correctly capturing <a href=\"/guide/loop-invs/#guide-loop-invs\">loop invariants</a> of the user of the abstraction on the inside of the abstraction.\n  Often, this means the abstraction must set up a protocol to communicate with its user, such as by receiving an invariant captured by an arrow expression.<a href=\"#p_2\" class=\"pid\">2</a>\n</p>\n<div class=\"note\">\n  <p><i id=\"p_3\" class=\"pid\"></i>See <a href=\"/workshop/#workshop-abstract-simul\">the abstraction workshop</a> for a walkthrough of building such an abstraction.<a href=\"#p_3\" class=\"pid\">3</a></p>\n</div>","<ul><li class=\"dynamic\"><a href=\"#guide-abstract\">Building decentralized abstractions</a></li></ul>"]