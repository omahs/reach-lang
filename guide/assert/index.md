[{"bookPath":"guide","title":"How and what to verify","titleId":"guide-assert","hasOtp":true,"hasPageHeader":true},"<h1 id=\"guide-assert\" class=\"refHeader\">How and what to verify<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#guide-assert\"><span class=\"icon icon-link\"></span></a></h1>\n<p><i id=\"p_0\" class=\"pid\"></i>Reach's verification engine ensures that invariants about the state of a program assumed by programmers are held by all possible executions of the program.<a href=\"#p_0\" class=\"pid\">0</a></p>\n<p>\n  <i id=\"p_1\" class=\"pid\"></i>At a high-level, the goal of a programmer getting started with verification is to write down <em>every single assumption they have</em> into the program in the form of <span class=\"snip\"><a href=\"/rsh/compute/#rsh_assert\" title=\"rsh: assert\"><span style=\"color: var(--shiki-color-text)\">assert</span></a></span> statements.\n  For example, if a value, <span class=\"snip\"><span style=\"color: var(--shiki-color-text)\">x</span></span> is assumed to be smaller than 20, then the programmer should always include <span class=\"snip\"><a href=\"/rsh/compute/#rsh_assert\" title=\"rsh: assert\"><span style=\"color: var(--shiki-token-function)\">assert</span></a><span style=\"color: var(--shiki-color-text)\">(x </span><a href=\"/rsh/compute/#rsh_%3C\" title=\"rsh: <\"><span style=\"color: var(--shiki-token-keyword)\">&lt;</span></a><span style=\"color: var(--shiki-color-text)\"> </span><span style=\"color: var(--shiki-token-constant)\">20</span><span style=\"color: var(--shiki-color-text)\">);</span></span> in the program.\n  This is not to help the verification engine prove later properties, but is to give the verification engine assumptions that it can attempt to falsify so the programmer can learn if their assumptions are correct.<a href=\"#p_1\" class=\"pid\">1</a>\n</p>\n<p>\n  <i id=\"p_2\" class=\"pid\"></i>At a low-level, the programmer should see the verification engine as a tool to prevent test regressions by encoding tests directly into the program in the form of assertions.\n  For example, suppose that during development and testing, a programmer observes an erroneous state where the variable <span class=\"snip\"><span style=\"color: var(--shiki-color-text)\">y</span></span> is assigned to the value <span class=\"snip\"><span style=\"color: var(--shiki-token-constant)\">41</span></span>, then the programmer should insert <span class=\"snip\"><a href=\"/rsh/compute/#rsh_assert\" title=\"rsh: assert\"><span style=\"color: var(--shiki-token-function)\">assert</span></a><span style=\"color: var(--shiki-color-text)\">(y </span><a href=\"/rsh/compute/#rsh_!=\" title=\"rsh: !=\"><span style=\"color: var(--shiki-token-keyword)\">!=</span></a><span style=\"color: var(--shiki-color-text)\"> </span><span style=\"color: var(--shiki-token-constant)\">41</span><span style=\"color: var(--shiki-color-text)\">);</span></span> into the program.\n  The programmer should insert this check <em>before</em> they fix the problem in the code.\n  This will ensure that all future versions of the program will also be protected from these problems.<a href=\"#p_2\" class=\"pid\">2</a>\n</p>\n<p>\n  <i id=\"p_3\" class=\"pid\"></i>These high- and low-level perspectives on assertions apply to individual code fragments, like the body of an <span class=\"snip\"><a href=\"/rsh/step/#rsh_only\" title=\"rsh: only\"><span style=\"color: var(--shiki-color-text)\">only</span></a></span> statement, as well as entire functions.\n  For example, if a programmer expects a unary function over integers, <span class=\"snip\"><span style=\"color: var(--shiki-color-text)\">f</span></span>, to always return a number between <span class=\"snip\"><span style=\"color: var(--shiki-token-constant)\">0</span></span> and <span class=\"snip\"><span style=\"color: var(--shiki-token-constant)\">50</span></span>, then they should write <span class=\"snip\"><a href=\"/rsh/compute/#rsh_assert\" title=\"rsh: assert\"><span style=\"color: var(--shiki-token-function)\">assert</span></a><span style=\"color: var(--shiki-color-text)\">(</span><span style=\"color: var(--shiki-token-function)\">f</span><span style=\"color: var(--shiki-color-text)\">(</span><a href=\"/rsh/compute/#rsh_forall\" title=\"rsh: forall\"><span style=\"color: var(--shiki-token-function)\">forall</span></a><span style=\"color: var(--shiki-color-text)\">(UInt)) </span><a href=\"/rsh/compute/#rsh_%3C=\" title=\"rsh: <=\"><span style=\"color: var(--shiki-token-keyword)\">&lt;=</span></a><span style=\"color: var(--shiki-color-text)\"> </span><span style=\"color: var(--shiki-token-constant)\">50</span><span style=\"color: var(--shiki-color-text)\">);</span></span> in their program.\n  Similarly, the unit tests for a function that a developer would normally write in a test suite, should instead be written as a series of assertions in the module that defines a function.<a href=\"#p_3\" class=\"pid\">3</a>\n</p>\n<p>\n  <i id=\"p_4\" class=\"pid\"></i>If you'd like to continue learning about verification, we recommend reading about <a href=\"https://duckduckgo.com/?q=property-based+testing\" target=\"_blank\">\"property-based testing\"</a>.\n  Although most resources on the topic will refer to dynamic, random tools, like <a href=\"https://en.wikipedia.org/wiki/QuickCheck\" target=\"_blank\">QuickCheck</a>, the strategies used transfer automatically to a formally verified context, like Reach.<a href=\"#p_4\" class=\"pid\">4</a>\n</p>\n<p><i id=\"p_5\" class=\"pid\"></i>If you'd like to continue reading about verification in Reach specifically, read <a href=\"/guide/loop-invs/#guide-loop-invs\">the guide section on loop invariants</a>.<a href=\"#p_5\" class=\"pid\">5</a></p>","<ul><li class=\"dynamic\"><a href=\"#guide-assert\">How and what to verify</a></li></ul>"]