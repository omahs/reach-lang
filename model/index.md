[{"bookPath":"","title":"Model","titleId":"ref-model","hasOtp":true,"hasPageHeader":true},"<h1 id=\"ref-model\" class=\"refHeader\">Model<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#ref-model\"><span class=\"icon icon-link\"></span></a></h1>\n<p><i id=\"p_0\" class=\"pid\"></i>This document describes the fundamental assumptions and concepts of Reach. First, we discuss the model of running a Reach program in <a href=\"/model/#ref-model-eval\">Evaluation Model</a>. Next, we discuss the details about compilation of a Reach program that are relevant to Reach programmers in <a href=\"/model/#ref-model-compile\">Compilation Model</a>. Finally, we discuss how Reach programs are syntactically constructed in <a href=\"/model/#ref-model-syntax\">Syntax Model</a>.<a href=\"#p_0\" class=\"pid\">0</a></p>\n<div class=\"note\">\n  <p>\n    <i id=\"p_1\" class=\"pid\"></i>This is not an introduction to Reach.\n    We recommend reading <a href=\"/tut/overview/#overview\">the overview</a> for an introduction to what Reach is and the <a href=\"/tut/rps/#tut\">tutorial</a> to get started with programming Reach.<a href=\"#p_1\" class=\"pid\">1</a>\n  </p>\n  <p>\n    <i id=\"p_2\" class=\"pid\"></i>Furthermore, it is not an introduction to consensus networks or \"blockchain\".\n    If you would like to read such an introduction, we recommend the <a href=\"https://en.wikipedia.org/wiki/Consensus_(computer_science)\" target=\"_blank\">Wikipedia article on consensus</a> and the <a href=\"https://en.wikipedia.org/wiki/Blockchain\" target=\"_blank\">Wikipedia article on blockchains</a>.<a href=\"#p_2\" class=\"pid\">2</a>\n  </p>\n</div>\n<h2 id=\"ref-model-eval\" class=\"refHeader\">Evaluation Model<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#ref-model-eval\"><span class=\"icon icon-link\"></span></a></h2>\n<p><i id=\"p_3\" class=\"pid\"></i>Reach programs specify a decentralized application (<span class=\"term\" id=\"term_DApp\">DApp</span>), which is a distributed computation involving many participants and utilizing one contract on one consensus network for reaching agreement on the intermediate values of the computation.<a href=\"#p_3\" class=\"pid\">3</a></p>\n<div class=\"note\">\n  <p><i id=\"p_4\" class=\"pid\"></i>\"Many\" is a technical term that means \"zero or more\".<a href=\"#p_4\" class=\"pid\">4</a></p>\n</div>\n<p><i id=\"p_5\" class=\"pid\"></i>When the computation terminates, all participants agree on the outcome, because they agreed on the intermediate values.<a href=\"#p_5\" class=\"pid\">5</a></p>\n<p><i id=\"p_6\" class=\"pid\"></i>At the start of a Reach computation, the set of participants is not necessarily known and can evolve throughout the execution of the application.<a href=\"#p_6\" class=\"pid\">6</a></p>\n<p>\n  <i id=\"p_7\" class=\"pid\"></i>A <span class=\"term\" id=\"term_consensus%20network\">consensus network</span> is a network protocol with a network token, a set of non-network tokens, a set of accounts, a set of contracts, and a network time.\n  A <span class=\"term\" id=\"term_network%20token\">network token</span> is an opaque unit of account.\n  A <span class=\"term\" id=\"term_non-network%20token\">non-network token</span> is an opaque unit of account;\n  typical consensus networks allow the set of non-network tokens to grow over time and be issued by accounts.<a href=\"#p_7\" class=\"pid\">7</a>\n</p>\n<div class=\"note\">\n  <p><i id=\"p_8\" class=\"pid\"></i>Reach assumes that network tokens and non-network tokens behave identically, but often they do not; <a href=\"/guide/nntoks/#guide-nntoks\">this article</a> discusses the causes and consequences of this.<a href=\"#p_8\" class=\"pid\">8</a></p>\n</div>\n<p>\n  <i id=\"p_9\" class=\"pid\"></i>A consensus network's <span class=\"term\" id=\"term_network%20time\">network time</span> is some monotonically increasing discrete value from a totally ordered set; typically, it is the height of the blockchain for consensus networks that use blockchains.\n  A <span class=\"term\" id=\"term_time%20delta\">time delta</span> represents the difference between two points in network time as a discrete number of network time units.\n  Each network time corresponds to some <span class=\"term\" id=\"term_network%20second\">network second</span>, which has a connection to real time; typically, it is a <a href=\"https://en.wikipedia.org/wiki/Unix_time\" target=\"_blank\">Unix time</a>.<a href=\"#p_9\" class=\"pid\">9</a>\n</p>\n<div class=\"note\">\n  <p><i id=\"p_10\" class=\"pid\"></i>This description of consensus networks is an abstraction that may not be directly implemented by actual networks.<a href=\"#p_10\" class=\"pid\">10</a></p>\n  <p>\n    <i id=\"p_11\" class=\"pid\"></i>For example, in UTXO-based networks, there is not typically an explicitly represented account balance ledger.\n    However, such networks do <em>abstractly</em> have accounts with balances, because particular private keys represent accounts which have exclusive access to some set of network tokens which is their balance.<a href=\"#p_11\" class=\"pid\">11</a>\n  </p>\n  <p>\n    <i id=\"p_12\" class=\"pid\"></i>Similarly, Reach's notion of time may appear overly abstract (\"monotonically increasing ... totally ordered set\") if you know that many consensus networks are based on blockchains and use the chain length, also called the height or block number, as a notion of time.\n    In this case, network time would be a natural number, which is a prototypical model of a totally ordered set.\n    However, Reach is flexible enough to support non-blockchain-based consensus networks, so it does not mandate this particular natural number-based notion of time.<a href=\"#p_12\" class=\"pid\">12</a>\n  </p>\n  <p>\n    <i id=\"p_13\" class=\"pid\"></i>Finally, Reach's definition of consensus network does not require any particular technology or features of this.\n    In particular, it does not only refer to so-called \"layer-1\" protocols, nor does it exclude centralized systems with trusted parties controlling the network.<a href=\"#p_13\" class=\"pid\">13</a>\n  </p>\n</div>\n<p>\n  <i id=\"p_14\" class=\"pid\"></i>Consensus networks support <span class=\"term\" id=\"term_transfers\">transfers</span> of network tokens and non-network tokens between accounts.\n  An <span class=\"term\" id=\"term_account\">account</span> is a unique identity (called an <span class=\"term\" id=\"term_address\">address</span>) with a non-negative balance of network tokens.\n  Accounts may sign values in a way that may not be repudiated or impersonated; this is called <span class=\"term\" id=\"term_publication\">publication</span>.\n  The chapter, <a href=\"/networks/#ref-networks\">Networks</a>, discusses which consensus networks are supported by Reach.<a href=\"#p_14\" class=\"pid\">14</a>\n</p>\n<p>\n  <i id=\"p_15\" class=\"pid\"></i><span class=\"term\" id=\"term_Contracts\">Contracts</span> are accounts with three extra capacities: they persistently store values (called the <span class=\"term\" id=\"term_consensus%20state\">consensus state</span>), they may receive publications, and when they receive publications, they systematically process them and may modify their consensus state, make publications, and may transfer network tokens and non-network tokens in response to the reception.\n  In addition to values, consensus state may contain a fixed number of <span class=\"term\" id=\"term_mappings\">mappings</span> between an address and a value.\n  These mappings are referred to as \"<span class=\"term\" id=\"term_linear%20state\">linear state</span>\" because their size is linear in the number of addresses visible to the contract.\n  Furthermore, a contract may provide <span class=\"term\" id=\"term_views\">views</span> of its consensus state, which are labeled functions and values which may be hierarchically organized, such as <code>NFT.owner</code> or <code>scoreOfPlayer</code>.\n  These views are visible in sub-trees of the computation graph.\n  A contract may also emit <span class=\"term\" id=\"term_event\">event</span>s, which are externally observable values that are persistently available.\n  On some networks, contracts have <span class=\"term\" id=\"term_companion\">companion</span>s, which are another contract that does work for them that cannot be done in the contract itself.\n  The creation of a contract is called <span class=\"term\" id=\"term_deploy\">deploy</span>ment.<a href=\"#p_15\" class=\"pid\">15</a>\n</p>\n<p>\n  <i id=\"p_16\" class=\"pid\"></i>A <span class=\"term\" id=\"term_participant\">participant</span> is a logical actor which takes part in a DApp.\n  It is associated with an account on the consensus network.<a href=\"#p_16\" class=\"pid\">16</a>\n</p>\n<div class=\"note\">\n  <p><i id=\"p_17\" class=\"pid\"></i>The same account may be used by multiple participants in a DApp.<a href=\"#p_17\" class=\"pid\">17</a></p>\n</div>\n<p><i id=\"p_18\" class=\"pid\"></i>A participant has persistently stored values, called its <span class=\"term\" id=\"term_local%20state\">local state</span>. It has a frontend which it interacts with. A <span class=\"term\" id=\"term_frontend\">frontend</span> is an abstract actor which supports a set of functions which consume and produce values; when a participant invokes one of these functions it is referred to as <span class=\"term\" id=\"term_interact\">interact</span>ion.<a href=\"#p_18\" class=\"pid\">18</a></p>\n<p>\n  <i id=\"p_19\" class=\"pid\"></i>A <span class=\"term\" id=\"term_participant%20class\">participant class</span> is a category of participant that may occur many times in a single application.\n  Members of a participant class are referred to as <span class=\"term\" id=\"term_participant%20instances\">participant instances</span> when their status as a member of a class is important, but just \"participants\" otherwise.\n  Participant instances are independent participants like any other; for example, with their own local state, frontend, and so on.\n  The main distinction is that when a member of a participant class joins an application, it is not fixed like other participants, because a participant instance does not exclusively represent the participant class.<a href=\"#p_19\" class=\"pid\">19</a>\n</p>\n<p>\n  <i id=\"p_20\" class=\"pid\"></i>An <span class=\"term\" id=\"term_API\">API</span> is a source of publications that do not correspond to any participant and are therefore like asynchronous events that impinge on the computation.\n  The contract returns a value to an API call.\n  APIs are organized into a labeled hierarchy, like <code>Contest.vote</code> and <code>User.write</code>.<a href=\"#p_20\" class=\"pid\">20</a>\n</p>\n<p><i id=\"p_21\" class=\"pid\"></i>Since DApps have an associated contract, they have an associated account.<a href=\"#p_21\" class=\"pid\">21</a></p>\n<div class=\"note\">\n  <p><i id=\"p_22\" class=\"pid\"></i>The contract account must be distinct from all participant accounts.<a href=\"#p_22\" class=\"pid\">22</a></p>\n</div>\n<p><i id=\"p_23\" class=\"pid\"></i>This account is assumed to be empty when the computation starts.<a href=\"#p_23\" class=\"pid\">23</a></p>\n<div class=\"note\">\n  <p><i id=\"p_24\" class=\"pid\"></i>On some consensus networks, it is possible for transfers to a contract account to occur outside of the purview of Reach. If this occurs, then those network tokens are remitted to the originator of the final consensus transfer.<a href=\"#p_24\" class=\"pid\">24</a></p>\n</div>\n<p><i id=\"p_25\" class=\"pid\"></i>Any network tokens transferred into the account must be removed by the DApp's completion. This is called the <span class=\"term\" id=\"term_token%20linearity%20property\">token linearity property</span>.<a href=\"#p_25\" class=\"pid\">25</a></p>\n<p><i id=\"p_26\" class=\"pid\"></i>A DApp computation can be seen as a graph of steps with a unique first step. A <span class=\"term\" id=\"term_step\">step</span> is a set of local steps by participants followed by a single consensus step introduced via a single consensus transfer.<a href=\"#p_26\" class=\"pid\">26</a></p>\n<p><i id=\"p_27\" class=\"pid\"></i>A <span class=\"term\" id=\"term_local%20step\">local step</span> is executed by a single participant and is a sequence of local computations. A <span class=\"term\" id=\"term_local%20computation\">local computation</span> may bind a piece of local state, assert a property of the local state, or interact with the frontend. A <span class=\"term\" id=\"term_consensus%20transfer\">consensus transfer</span> is executed by a single participant (called the <span class=\"term\" id=\"term_originator\">originator</span>) which makes a publication of a set of public values from its local state and transfers zero or more network tokens to the contract account. A consensus transfer specifies an alternative step, called a <span class=\"term\" id=\"term_timeout\">timeout</span>, that is executed if the originator fails to make the transfer before a given time delta has elapsed. All local state is initially <span class=\"term\" id=\"term_private\">private</span>, until it is explicitly made <span class=\"term\" id=\"term_public\">public</span> via a <span class=\"term\" id=\"term_declassification\">declassification</span>, which is a kind of local computation.<a href=\"#p_27\" class=\"pid\">27</a></p>\n<p>\n  <i id=\"p_28\" class=\"pid\"></i>A participant is said to <span class=\"term\" id=\"term_join\">join</span> an application when it first makes a publication.\n  For non-participant instances, this also makes the participant <span class=\"term\" id=\"term_fixed\">fixed</span>, whereby the consensus state includes an assignment from the participant to the particular account (i.e. address) which it is fixed to.\n  All subsequent publications by a fixed participant must be from the fixed account.<a href=\"#p_28\" class=\"pid\">28</a>\n</p>\n<p>\n  <i id=\"p_29\" class=\"pid\"></i>A <span class=\"term\" id=\"term_consensus%20step\">consensus step</span> is a graph of consensus computations with a unique first computation.\n  A <span class=\"term\" id=\"term_consensus%20computation\">consensus computation</span> either binds consensus state,\n  asserts a property of the consensus state,\n  performs a transfer,\n  selects between different next consensus computations,\n  communicates with another contract (referred to as a remote object),\n  or <span class=\"term\" id=\"term_commits\">commits</span> to the next step.<a href=\"#p_29\" class=\"pid\">29</a>\n</p>\n<p>\n  <i id=\"p_30\" class=\"pid\"></i>An <span class=\"term\" id=\"term_assert\">assert</span>ion is either: a <span class=\"term\" id=\"term_knowledge%20assertion\">knowledge assertion</span>, which is a claim that one honest participant cannot know something that another honest participant does know; a <span class=\"term\" id=\"term_static%20assertion\">static assertion</span>, which is an always-true formula; an <span class=\"term\" id=\"term_assumption\">assumption</span>, which is a true formula if frontends behave honestly; a <span class=\"term\" id=\"term_requirement\">requirement</span>, which is a true formula if participants behave honestly; or, a <span class=\"term\" id=\"term_possibility%20assertion\">possibility assertion</span>, which is a formula for which there exists some values that honest participants and frontends could submit which results in the truth of the formula.\n  An <span class=\"term\" id=\"term_honest\">honest</span> participant is one that executes the steps specified by the DApp, while an honest frontend is one that only returns values which ensure that all assumptions evaluate to the boolean <span class=\"snip\"><a href=\"/rsh/compute/#rsh_true\" title=\"rsh: true\"><span style=\"color: var(--shiki-token-constant)\">true</span></a></span>.<a href=\"#p_30\" class=\"pid\">30</a>\n</p>\n<p>\n  <i id=\"p_31\" class=\"pid\"></i>A <span class=\"term\" id=\"term_value\">value</span> is either: the <code>null</code> value, a boolean, an unsigned integer, a string of bytes, a digest, an address, a fixed tuple of values, a statically-sized homogeneous array of values, or a fixed record of values.\n  Values may be <span class=\"term\" id=\"term_digest\">digest</span>ed to produce a <a href=\"https://en.wikipedia.org/wiki/Cryptographic_hash_function\" target=\"_blank\">cryptographic hash</a> of their binary encoding.<a href=\"#p_31\" class=\"pid\">31</a>\n</p>\n<p>\n  <i id=\"p_32\" class=\"pid\"></i>Values are in one of three possible conditions.\n  They could be consensus state, in which case they are known to all participants.\n  They could be local state of a single participant, which means they are known by only that participant.\n  Local state is further divided into private local state, which cannot be included in a publication, and public local state, which can.\n  These conditions are summarized thus:<a href=\"#p_32\" class=\"pid\">32</a>\n</p>\n<ul>\n  <li><i id=\"p_33\" class=\"pid\"></i><strong>Local, private</strong>: The initial state.<a href=\"#p_33\" class=\"pid\">33</a></li>\n  <li><i id=\"p_34\" class=\"pid\"></i><strong>Local, public</strong>: The result of <span class=\"snip\"><a href=\"/rsh/local/#rsh_declassify\" title=\"rsh: declassify\"><span style=\"color: var(--shiki-color-text)\">declassify</span></a></span>.<a href=\"#p_34\" class=\"pid\">34</a></li>\n  <li><i id=\"p_35\" class=\"pid\"></i><strong>Consensus</strong>: The result of <span class=\"snip\"><a href=\"/rsh/step/#rsh_publish\" title=\"rsh: publish\"><span style=\"color: var(--shiki-color-text)\">publish</span></a></span>.<a href=\"#p_35\" class=\"pid\">35</a></li>\n</ul>\n<h2 id=\"ref-model-compile\" class=\"refHeader\">Compilation Model<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#ref-model-compile\"><span class=\"icon icon-link\"></span></a></h2>\n<p>\n  <i id=\"p_36\" class=\"pid\"></i>Reach programs cannot execute independently of a consensus network and a set of frontends.\n  Thus, the semantics of Reach treats these components abstractly and does not specify their semantics.\n  Therefore, the semantics of Reach cannot be effectively implemented directly in a virtual machine or interpreter.\n  Instead, Reach programs are <span class=\"term\" id=\"term_compile\">compile</span>d to\n  a particular consensus network <span class=\"term\" id=\"term_connector\">connector</span>\n  and a set of participant <span class=\"term\" id=\"term_backends\">backends</span>\n  which execute the computation of the particular consensus network.\n  Connectors and backends are sound\n  if they faithfully model the abstract semantics assumed by Reach.<a href=\"#p_36\" class=\"pid\">36</a>\n</p>\n<p>\n  <i id=\"p_37\" class=\"pid\"></i>During compilation, the Reach compiler automatically verifies that the token linearity property and all static assertions and possibility assertions are true whether participants and frontends are honest or not.\n  Similarly, all knowledge assertions are verified using a conservative approximation of participant knowledge.\n  This conservative approximation assumes that all inputs to a computation are revealed by the result of the computation, except for digests and interaction.\n  This approximation means that Reach cannot, for example, reason about the details of manually expressed encryption formulas and will assume they are insecure.\n  Finally, a subtle point about the knowledge checker is relevant: technically participants with different identities in a Reach program may actually be instantiated by the same principals, i.e. if Alice choses to play a game of a Chess against herself, where she controls both Black and White; as this is always possible, the knowledge checker does not consider it a violation of a claim that White knows something Black does not.<a href=\"#p_37\" class=\"pid\">37</a>\n</p>\n<p>\n  <i id=\"p_38\" class=\"pid\"></i>If these assertions cannot be statically verified, then the compilation process aborts.\n  After this verification, such static assertions and possibility assertions are removed from the program and do not occur at runtime.\n  In contrast, assumptions are enforced at runtime by backends and requirements are enforced at runtime by connectors.\n  If assumptions are violated at runtime, then the backend aborts.\n  If requirements are violated at runtime, then the connector ensures that all aspects of the DApp (the contract and participant) ignore the inducing consensus transfer, which often results in a timeout.<a href=\"#p_38\" class=\"pid\">38</a>\n</p>\n<h2 id=\"ref-model-syntax\" class=\"refHeader\">Syntax Model<a aria-hidden=\"true\" tabindex=\"-1\" href=\"#ref-model-syntax\"><span class=\"icon icon-link\"></span></a></h2>\n<p><i id=\"p_39\" class=\"pid\"></i>Reach programs are specified via a subset of well-formed JavaScript syntax inside source files. The section <a href=\"/rsh/#ref-programs\">Language</a> describes the syntax of Reach programs in detail.<a href=\"#p_39\" class=\"pid\">39</a></p>","<ul><li class=\"dynamic\">\n    <a href=\"#ref-model\">Model</a>\n    <ul class=\"dynamic\">\n      <li class=\"dynamic\"><a href=\"#ref-model-eval\">Evaluation Model</a></li>\n      <li class=\"dynamic\"><a href=\"#ref-model-compile\">Compilation Model</a></li>\n      <li class=\"dynamic\"><a href=\"#ref-model-syntax\">Syntax Model</a></li>\n    </ul>\n  </li></ul>"]